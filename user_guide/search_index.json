[
["index.html", "AZRtools documentation User Guide", " AZRtools documentation Devin Pastoor Imad Mali User Guide The user guide documents the functionality for the AZRsim R package which can be used to simulate ordinary differential equations in C and NONMEM. In order to simulate the model in the AZRsim package we have to, Create an appropriate text file representation of the model. Compile the model with the create_model() function. Simulate the compiled model with the simulate() function. "],
["installation.html", "1 Installation", " 1 Installation The following does not apply to those who do not have access to the package while it is being maintained on GitHub as a private repository. The AZRsim package can be installed from the AZRQCP repository as follows: devtools::install_github(&quot;AZRQCP/AZRsim&quot;) "],
["model-specification.html", "2 Model Specification 2.1 Model Name and Model Notes 2.2 Model States 2.3 Model Parameters 2.4 Model Variables 2.5 Model Reactions 2.6 Model Functions 2.7 Model Events", " 2 Model Specification In order to simulate the time varying variables of a system of ordinary differential equations you need to provide a specific representation of your mathematical model in a text file (a file with extension .txt). Every text file representation of a model must contain the following blocks presented exactly as defined below. Notice that each block name is preceded with ten *s. It is possible to comment out a line of code using %. ********** MODEL NAME ********** MODEL NOTES ********** MODEL STATES ********** MODEL PARAMETERS ********** MODEL VARIABLES ********** MODEL REACTIONS ********** MODEL FUNCTIONS ********** MODEL EVENTS The remainder of this section deals with what can be declared within each block. 2.1 Model Name and Model Notes MODEL NAME and MODEL NOTES are descriptive blocks that allow the user to specify a model name and any notes about the model. The name of the model will be presented when an azrmod object is printed to the console. Below are the model name and model notes blocks for the simple harmonic oscillator example in the AZRsim package (sho.txt). ********** MODEL NAME Harmonic Oscillator ********** MODEL NOTES Harmonic Oscillator ODE example. This meta data can be extracted from an azrmod object. 2.2 Model States The MODEL STATES block is where the user describes the system of differential equations followed by the initial conditions for each variable. The left hand side of each differential equation must be declared as d/dt(x) where x is a variable name chosen by the user. The initial conditions must be defined, and they must be defined after the system of differential equations is defined. If variable x in the preceding paragraph had an initial condition value of 3 then we can declare x(0) = 3 after defining the system of differential equations. 2.3 Model Parameters The MODEL PARAMETERS block is where the user defines the values of the parameters in the system of differential equations defined in MODEL STATES. 2.4 Model Variables The MODEL VARIABLES block provides a way to reparametrize parts of the model. Variables for intermediate calculations should be defined under MODEL VARIABLES. ********** MODEL STATES d/dt(A) = -R d/dt(B) = R A(0) = 1 B(0) = 0 ********** MODEL PARAMETERS k1 = 0.5 ********** MODEL VARIABLES R = k1*A 2.5 Model Reactions The MODEL REACTIONS block provides a way to reparametrize parts of the model. Reaction rates should be defined in the MODEL REACTIONS block. ********** MODEL STATES d/dt(A) = -R d/dt(B) = R A(0) = 1 B(0) = 0 ********** MODEL PARAMETERS k1 = 0.5 ********** MODEL REACTIONS R = k1*A 2.6 Model Functions The MODEL FUNCTIONS block can be used to define reoccuring calculations. As an example, the sho_func.txt example model in the AZRsim package applies the function \\(f(x) = \\frac{x}{100}\\) to the variable \\(y_2\\) in \\(\\frac{d}{dt}y_2\\) equation in the system. ********** MODEL NAME Simple Harmonic Oscillator ********** MODEL NOTES Simple Harmonic Oscillator ODE example. ********** MODEL STATES % ODE system d/dt(y1) = y2 d/dt(y2) = - y1 - theta * f(y2) % initial conditions y1(0) = 1 y2(0) = 0 ********** MODEL PARAMETERS theta = 0.15 ********** MODEL VARIABLES ********** MODEL REACTIONS ********** MODEL FUNCTIONS f(x) = x * 0.01 ********** MODEL EVENTS 2.7 Model Events The MODEL EVENTS block can be used to define discrete state events. Note that the declaration of events is not vectorized. There are essentially two parts to defining a discrete event in the model: When does the event take place? What is the event? Below is an example of a event block. ********* MODEL EVENTS event1 = eq(time, 1), y, y+40 event2 = eq(time, 2), y, y+40 The term eq(time, 1) pertains to (1). This says that the event occurs when the time step is strictly equal to 1. The term y, y+40 pertains to (2). This is the event that is to take place. In this case the event involves variable y and we want to add 40 units of the drug this variable, y+40. (Note that events cannot take place at time 0.) In summary, the above block defines adding 40 to the value of y at time steps 1 and 2. We can issue multiple events. The event defined below specifies resetting the value of x to 1 and y to 0 when x is equal to 0.1. ********* MODEL EVENTS event = eq(x, 0.1), x, 1, y, 0 Below is a summary of the options that can be used to declare when an event takes place. eq(a, 0) implies variable a is strictly equal to 0. lq(a, 0) implies variable a is less than or equal to 0. gq(a, 0) implies variable a is greater than or equal to 0. lt(a, 0) implies variable a is strictly less than 0. gt(a, 0) implies variable a is strictly greater than 0. "],
["modeling-functions.html", "3 Modeling Functions 3.1 create_model 3.2 simulate 3.3 plot 3.4 shiny_plot", " 3 Modeling Functions This section specifies the user-facing functions required to simulate the system of ordinary differential equations. 3.1 create_model The create_model function is used to create the C code based on the text file representation of the model. This function returns and object of class azrmod. Once you create a model you can print a summary of the model in R. Below is an example of printing the simple harmonic oscillator, which is part of the AZRsim package. library(AZRsim) sho &lt;- create_model(system.file(&quot;examples/sho.txt&quot;, package=&quot;AZRsim&quot;)) sho #&gt; AZRmodel #&gt; ======== #&gt; Name: Harmonic Oscillator #&gt; Number States: 2 #&gt; Number Parameters: 1 #&gt; Number Variables: 0 #&gt; Number Reactions: 0 #&gt; Number Functions: 0 In this model, the system of differential equations involves two states (\\(y_1\\) and \\(y_2\\)) and one parameter (\\(\\theta\\)). The azrmod object is a list and we can extract the meta data that was declared in the Model Name and Model Notes block by using $ to access the elements within the list. Continuing the above example, below is the code that allows the user print the meta data associated with the sho.txt example model to the R console. sho$name #&gt; [1] &quot;Harmonic Oscillator&quot; sho$notes #&gt; [1] &quot;Harmonic Oscillator ODE example.&quot; 3.2 simulate Once you have created an azrmod object with create_model you can use the simulate generic to simulate the state variables over a specified number of time steps. Note that the simulate function requires an object of class azrmod, and will return an object of class azrsim and data.frame. In the simple harmonic oscillator example above we have two states, so calling simulate(sho, seq(1, 100, by=0.1)) will provide a simulation of these two states over the time sequence 1 to 100 at 0.1 intervals. sho_sim &lt;- simulate(sho, seq(1, 100, by=0.1)) #&gt; Warning: package &#39;bindrcpp&#39; was built under R version 3.3.3 head(sho_sim) #&gt; TIME y1 y2 #&gt; 1 1.0 1.000 0.0000 #&gt; 2 1.1 0.995 -0.0991 #&gt; 3 1.2 0.980 -0.1957 #&gt; 4 1.3 0.956 -0.2890 #&gt; 5 1.4 0.923 -0.3780 #&gt; 6 1.5 0.881 -0.4619 dim(sho_sim) #&gt; [1] 991 3 3.3 plot The plot generic can be called on an azrsim object and, by default, will construct a lattice plot of the first 9 parameters over time. plot(sho_sim, col = &quot;#FF6688&quot;, lwd = 3) 3.4 shiny_plot The shiny_plot function must be called on an azrsim object and will launch a shiny app that will allow the user to interactively include/exclude any state variable estimated. "],
["dosing.html", "4 Dosing 4.1 Dosing in the Model Events Block 4.2 Dosing with a Dosing Table 4.3 Outputs", " 4 Dosing Dosing can be handled either in the Model Events block or by providing a data frame that describes a dosing table that can be called into the simulate function as the argument dosingTable. Both approaches are discussed below using, as an example, the following model of a simple one compartment model. \\[ \\frac{d}{dt}y = -\\theta \\cdot y \\] 4.1 Dosing in the Model Events Block The model below defines dosing within the Model Events block for a simple one compartment model. ********** MODEL NAME Simple One Compartment Dosing Model ********** MODEL NOTES A simple one compartment dosing model where ten equally spaced doses are given to the subject. ********** MODEL STATES d/dt(y) = -theta * y y(0) = 0 ********** MODEL PARAMETERS theta = 0.6 ********** MODEL VARIABLES ********** MODEL REACTIONS ********** MODEL FUNCTIONS ********** MODEL EVENTS % adding 40 units at a specified time step event1 = eq(time, 1), y, y+40 event2 = eq(time, 2), y, y+40 event3 = eq(time, 3), y, y+40 event4 = eq(time, 4), y, y+40 event5 = eq(time, 5), y, y+40 event6 = eq(time, 6), y, y+40 event7 = eq(time, 7), y, y+40 event8 = eq(time, 8), y, y+40 event9 = eq(time, 9), y, y+40 Below we compile the model, simulate, and plot the variable. one_cpt &lt;- create_model(system.file(&quot;examples/one_cpt.txt&quot;, package=&quot;AZRsim&quot;)) #&gt; Warning in check_azrmod(model): check_azrmod: AZRmodel contains state names #&gt; with a single character name. Try to avoid that if you plan to use NONMEM #&gt; or MONOLIX one_cpt_simulation &lt;- simulate(one_cpt, simtime = 10) #&gt; Warning: package &#39;bindrcpp&#39; was built under R version 3.3.3 plot(one_cpt_simulation, col = &quot;#808080&quot;, lwd = 3, plot_names = &quot;blood&quot;) 4.2 Dosing with a Dosing Table The model below defines an analogous dosing regimen using the INPUT* variable in the system of differential equations for the same model. Note that INPUT* must be applied to the relevant variables in the Model States block. In this context a dose (the units of which will be defined in the dosing table) is added to the variable y at specific time intervals (also defined in the dosing table). ********** MODEL NAME Simple One Compartment Dosing Model ********** MODEL NOTES A simple one compartment dosing model where the doses must be defined as a data frame in the &#39;dosingTable&#39; argument of the simulate function. ********** MODEL STATES d/dt(y) = -theta * y + INPUT1 y(0) = 0 ********** MODEL PARAMETERS theta = 0.6 ********** MODEL VARIABLES ********** MODEL REACTIONS ********** MODEL FUNCTIONS ********** MODEL EVENTS Below we construct a dosing table, compile the model, simulate, and plot the variable. The dosing table must be a data frame with the following columns, TIME - the time at which the does occurs. DOSE - the units of the dose. DURATION - how long the dose is administered. INPUT - which input variable the dose is associated with. LAGTIME - the lag time associated with each dose. one_cpt_dt &lt;- create_model(system.file(&quot;examples/one_cpt_dt.txt&quot;, package=&quot;AZRsim&quot;)) #&gt; Warning in check_azrmod(model): check_azrmod: AZRmodel contains state names #&gt; with a single character name. Try to avoid that if you plan to use NONMEM #&gt; or MONOLIX dt &lt;- data.frame(&quot;TIME&quot; = seq(1,9, by = 1), &quot;DOSE&quot; = 40, &quot;DURATION&quot; = 0, &quot;INPUT&quot; = 1, &quot;LAGTIME&quot; = 0, stringsAsFactors = FALSE) one_cpt_dt_simulation &lt;- simulate(one_cpt_dt, 10, dosingTable = dt) plot(one_cpt_dt_simulation, col = &quot;#808080&quot;, lwd = 3, pars = &quot;y&quot;, plot_names = &quot;blood&quot;) 4.3 Outputs It is also possible to defined outputs from using OUTPUT* in the model. An example is provided below where the output is half of the state variable. ********** MODEL NAME Simple One Compartment Dosing Model ********** MODEL NOTES A simple one compartment dosing model where the doses must be defined as a data frame in the &#39;dosingTable&#39; argument of the simulate function. ********** MODEL STATES d/dt(y) = -theta * y + INPUT1 y(0) = 0 ********** MODEL PARAMETERS theta = 0.6 ********** MODEL VARIABLES y_new = y/2 OUTPUT1 = y_new ********** MODEL REACTIONS ********** MODEL FUNCTIONS ********** MODEL EVENTS Below we compile the model, simulate the state variables, and plot the results. one_cpt_out &lt;- create_model(system.file(&quot;examples/one_cpt_output.txt&quot;, package=&quot;AZRsim&quot;)) #&gt; Warning in check_azrmod(model): check_azrmod: AZRmodel contains state names #&gt; with a single character name. Try to avoid that if you plan to use NONMEM #&gt; or MONOLIX dt &lt;- data.frame(&quot;TIME&quot; = seq(1,9, by = 1), &quot;DOSE&quot; = 40, &quot;DURATION&quot; = 0, &quot;INPUT&quot; = 1, &quot;LAGTIME&quot; = 0, stringsAsFactors = FALSE) one_cpt_out_simulation &lt;- simulate(one_cpt_out, 10, dosingTable = dt, output = c(&quot;y&quot;, &quot;OUTPUT1&quot;)) plot(one_cpt_out_simulation, col = &quot;#808080&quot;, lwd = 3, plot_names = c(&quot;blood (y)&quot;, &quot;blood (y/2)&quot;)) "],
["examples.html", "5 Examples 5.1 Simple Harmonic Oscillator 5.2 Two Compartment Model", " 5 Examples 5.1 Simple Harmonic Oscillator The equations that govern a harmonic oscillator are the following, \\[\\begin{align*} \\frac{d}{dt}y_1 &amp;= y_2 \\\\ \\frac{d}{dt}y_2 &amp;= - y_1-\\theta \\cdot y_2 \\end{align*}\\] where \\(y_1\\), \\(y_2\\) are state variables and \\(\\theta\\) is a parameter in this model. The text file representation of the model is provided below. ********** MODEL NAME Harmonic Oscillator ********** MODEL NOTES Harmonic Oscillator ODE example. ********** MODEL STATES d/dt(y1) = y2 d/dt(y2) = - y1 - theta * y2 y1(0) = 1 y2(0) = 0 ********** MODEL PARAMETERS theta = 0.15 ********** MODEL VARIABLES ********** MODEL REACTIONS ********** MODEL FUNCTIONS ********** MODEL EVENTS Compiling and simulating the model. sho_model &lt;- create_model(system.file(&quot;examples/sho.txt&quot;, package=&quot;AZRsim&quot;)) sho_sim &lt;- simulate(sho_model, seq(0, 100, by=0.1)) #&gt; Warning: package &#39;bindrcpp&#39; was built under R version 3.3.3 head(sho_sim) #&gt; TIME y1 y2 #&gt; 1 0.0 1.000 0.0000 #&gt; 2 0.1 0.995 -0.0991 #&gt; 3 0.2 0.980 -0.1957 #&gt; 4 0.3 0.956 -0.2890 #&gt; 5 0.4 0.923 -0.3780 #&gt; 6 0.5 0.881 -0.4619 Plotting variables as a function of time. plot(sho_sim, col = &quot;#808080&quot;, lwd = 3) Plotting the variables as a function of each other. plot(sho_sim[,&quot;y1&quot;], sho_sim[,&quot;y2&quot;], type = &quot;l&quot;, col = &quot;#808080&quot;, lwd = 2, xlab = &quot;y1&quot;, ylab = &quot;y2&quot;) 5.2 Two Compartment Model Here we consider a simple two compartment model where, for example, we model the concentration of an oral drug in the intestines and in the blood. The ODE system takes the following form, \\[\\begin{align*} \\frac{d}{dt}y_1 &amp;= -a \\cdot y_1 + u_t \\\\ \\frac{d}{dt}y_2 &amp;= a \\cdot y_1 - b \\cdot y_2 \\end{align*}\\] where \\(y_1\\) denotes the concetration of the drug the intenstine, \\(y_2\\) denotes the concentration of the drug in the blood, \\(a\\) and \\(b\\) are parameters, and \\(u_t\\) denotes the uptake of the drug at time period \\(t\\). The text file representation of the model above provided below. ********** MODEL NAME Simple Two Compartment Dosing Model ********** MODEL NOTES A simple two compartment dosing model where ten equally spaced doses are given to the subject. ********** MODEL STATES d/dt(y1) = -a * y1 d/dt(y2) = a * y1 - b * y2 y1(0) = 0 y2(0) = 0 ********** MODEL PARAMETERS a = 6 b = 0.6 ********** MODEL VARIABLES ********** MODEL REACTIONS ********** MODEL FUNCTIONS ********** MODEL EVENTS % adding 40 units at a specified time step event1 = eq(time, 1), y1, y1+2 event2 = eq(time, 2), y1, y1+2 event3 = eq(time, 3), y1, y1+2 event4 = eq(time, 4), y1, y1+2 event5 = eq(time, 5), y1, y1+2 event6 = eq(time, 6), y1, y1+2 event7 = eq(time, 7), y1, y1+2 event8 = eq(time, 8), y1, y1+2 event9 = eq(time, 9), y1, y1+2 Below the model is compiled and simulated and the 10 initial and final values are presented. two_cpt &lt;- create_model(system.file(&quot;examples/two_cpt.txt&quot;, package=&quot;AZRsim&quot;)) #&gt; Warning in check_azrmod(model): check_azrmod: AZRmodel contains parameter #&gt; names with a single character name. Try to avoid that if you plan to use #&gt; NONMEM or MONOLIX two_cpt_simulation &lt;- simulate(two_cpt, simtime = 10) head(two_cpt_simulation, n = 10) #&gt; TIME y1 y2 #&gt; 1 0.00 0 0 #&gt; 2 0.01 0 0 #&gt; 3 0.02 0 0 #&gt; 4 0.03 0 0 #&gt; 5 0.04 0 0 #&gt; 6 0.05 0 0 #&gt; 7 0.06 0 0 #&gt; 8 0.07 0 0 #&gt; 9 0.08 0 0 #&gt; 10 0.09 0 0 tail(two_cpt_simulation, n = 10) #&gt; TIME y1 y2 #&gt; 992 9.91 0.00853 2.83 #&gt; 993 9.92 0.00803 2.81 #&gt; 994 9.93 0.00757 2.80 #&gt; 995 9.94 0.00713 2.78 #&gt; 996 9.95 0.00671 2.77 #&gt; 997 9.96 0.00632 2.75 #&gt; 998 9.97 0.00595 2.73 #&gt; 999 9.98 0.00561 2.72 #&gt; 1000 9.99 0.00528 2.70 #&gt; 1001 10.00 0.00497 2.69 Using the plot generic we can plot the simulation to visualize the concentration of the drug in both compartments over time. plot(two_cpt_simulation, col = &quot;#808080&quot;, lwd = 3, plot_names = c(&quot;intestines&quot;, &quot;blood&quot;)) Below we simulate the model with a different parameter value for \\(b\\). two_cpt_simulation2 &lt;- simulate(two_cpt, simtime = 10, parameters = c(&quot;a&quot; = 6, &quot;b&quot; = 1)) plot(two_cpt_simulation2, col = &quot;#808080&quot;, lwd = 3, plot_names = c(&quot;intestines&quot;, &quot;blood&quot;)) "],
["azrnlme.html", "6 AZRnlme 6.1 Running a model 6.2 dosing 6.3 project path 6.4 data 6.5 model specification: 6.6 algorithm spec 6.7 Additional Assumptions", " 6 AZRnlme 6.1 Running a model A full workflow may look like the following: # Load the create_model model &lt;- create_model(&quot;model.txt&quot;) # Define type of dosing that appears in the model dosing &lt;- list( INPUT1 = c(type=&quot;BOLUS&quot;) ) # Define path for NONMEM model export projectPath &lt;- &quot;MODEL_01&quot; # Define data information data &lt;- list( relPathFromProject = &quot;..&quot;, fileName = &quot;data.csv&quot;, headerIdent = &quot;IGNORE,ID,IGNORE,IGNORE,IGNORE,TIME,TIMEPOS,TAD,IGNORE,IGNORE,YTYPE,IGNORE,DV,IGNORE,CENS,MDV,EVID,AMT,ADM,IGNORE,RATE,IGNORE,IGNORE,COV,CAT&quot; ) # Define model specifications related to the parameter, statistical, covariate model modelSpec &lt;- list( # Fixed effect POPvalues0 = c(ka=2, CL=40, Vc=2), POPestimate = c(ka=1, CL=1, Vc=1), # Random effects IIVvalues0 = c(ka=0.3, CL=0.4, Vc=0.5), IIVestimate = c(ka=1, CL=1, Vc=1), IIVdistribution = c(ka=&quot;L&quot;, CL=&quot;L&quot;, Vc=&quot;L&quot;) ) # Create the NONMEM model create_project(model, dosing, projectPath, data, modelSpec = modelSpec) # Run the NONMEM model run_project(projectPath) also of note, is that parameters much be declared as being an estimate or a regressor ********** MODEL PARAMETERS ka = 1 % (1/hours) &lt;estimate&gt; CL = 3 % (L/hours) &lt;estimate&gt; Vc = 60 % &lt;estimate&gt; 6.2 dosing Dosing can be specified of the type: BOLUS INFUSION ABSORPTION0 and is linked to an input dosing &lt;- list( INPUT1 = c(type=&quot;BOLUS&quot;) ) 6.3 project path The project path sets where the nonmem model and data should be placed for execution. If the path does not exist, it will be created. If it does exist, the files will be overwritten when a model is created It may be stored as a variable (recommended) or can be directly referenced. projectPath &lt;- &quot;MODEL_01&quot; 6.4 data Define data information There are a number of data requirements that must be met: IXGDF - Index column USUBJID - Subject ID ID - nonmem-style ID TIME - Time TIMEPOS - Time, with no times less than 0 TAD - Time after dose DV - primary dependent variable MDV - missing dependent variable flag EVID - nonmem event ID CENS - censoring flag AMT - amount ADM - administration flag RATE - rate flag Given a dataset, the location of these columns, and any others to be kept or ignored (replace name with IGNORE) must be provided in the data object as a comma separated list with no spaces called headerIndent. data &lt;- list( relPathFromProject = &quot;..&quot;, fileName = &quot;data.csv&quot;, headerIdent = &quot;IGNORE,ID,IGNORE,IGNORE,IGNORE,TIME,TIMEPOS,TAD,IGNORE,IGNORE,YTYPE,IGNORE,DV,IGNORE,CENS,MDV,EVID,AMT,ADM,IGNORE,RATE,IGNORE,IGNORE,COV,CAT&quot; ) 6.5 model specification: POPestimate POPvalues0 IIVdistribution IIVestimate IIVvalues0 errorModel covarianceModel covariateModel covariateModelValues COVestimate COVcentering with less common arguments also accepted: METHOD MAXEVAL SIGDIGITS PRINT M4 SEED K1 K2 NRCHAINS IMPORTANCESAMPLING IMP_ITERATIONS ITS ITS_ITERATIONS The common details are described below 6.5.1 POPvalues0 and POPestimate POPvalues and estimate set the initial values and whether to estimate modelSpec &lt;- list( # ... POPvalues0 = c(ka=2, CL=40, Vc=2), POPestimate = c(ka=1, CL=1, Vc=1), ) 6.5.2 IIVdistribution because the underlying ODE system does not support heirarchical constructs, the value of a single parameter can be overloaded to treat it as a heirarchical parameter by declaring one of 3 supported distribution, Lognormal, Normal, and G-logitnormal 6.5.3 IIVvalues0 and IIVestimate The IIVestimate specifies the initial estimate of the IIV parameters modelSpec &lt;- list( # ... IIVvalues0 = c(ka=1, CL =1.4, Vc = 10.8), IIVestimate = c(ka=1, CL=1, Vc=1) ) 6.5.4 errorModel Error models are linked to outputs and can be either abs, rel, or absrel and must be specified as a list. modelSpec &lt;- list( # ... errorModel = list( OUTPUT1 = c(&quot;absrel&quot;, c(abs=1,rel=0.1)) ) ) 6.5.5 covarianceModel Given a need to set some components of the covariance model to be a block, and others to be diagnoal, the block elements may be passed as a vector of names to the covarianceModel, where all elements in a block are specified as a comma separated list. For example, given the desire for a block matrix between CL/V and a diagnal for Ka, it would be coded as such: modelSpec &lt;- list( # Define the block diagonal elements covarianceModel = c(&quot;CL,V&quot;) ) 6.5.6 covariateModel The covariateModel element specifies the relationship between the parameter and covariates of interest modelSpec &lt;- list( # ... covariateModel = list( CL = c(&quot;WT0&quot;,&quot;SEX&quot;), ka = c(&quot;SEX&quot;), Vc = c(&quot;WT0&quot;) ) ) 6.5.7 covariateModelValues modelSpec &lt;- list( # ... covariateModelValues = list( CL = c(WT0=0.75, SEX=0.3), ka = c(SEX=0.5), Vc = c(WT0=1) ) ) 6.5.8 COVestimate Set covariate parameters to be estimated (1) or not (0) modelSpec &lt;- list( # ... COVestimate = list( CL = c(WT0=0, SEX=1), ka = c(SEX=1), Vc = c(WT0=0) ) ) 6.5.9 COVcentering Define custom centering / reference values for covariates. For continuous covariates, the default is to take the median value. (note: this behavior will be under discussion. This was provided as-is for the initial implementation, however Devin has significant issues with this approach. Namely, the transferability of model interpretation is weak as the centering value will be different across datasets. Furthermore, given a desire to selectively include/exclude outlier subjects, the across the analysis a different centering value may apply. Better to center on a reasonable reference value, for example, a 70kg, 40yr old male). for categorical values the default is the lowest group number modelSpec &lt;- list( # ... COVcentering = c(WT0=70, RACE=2) ) 6.6 algorithm spec For the arguments, an example may look like algorithmSpec &lt;- list( METHOD = &quot;FOCEI&quot;, MAXEVAL = 9999, SIGDIGITS = 3, PRINT = 1, M4 = FALSE, SEED = 123456, or for Iterative 2 stage into SAEM algorithmSpec &lt;- list( METHOD = &quot;SAEM&quot;, MAXEVAL = 9999, SIGDIGITS = 3, PRINT = 1, M4 = FALSE, SEED = 123456, K1 = 500, K2 = 200, NRCHAINS = 1, ITS = TRUE, ITS_ITERATIONS = 50, IMPORTANCESAMPLING = TRUE, IMP_ITERATIONS = 50 ) 6.7 Additional Assumptions MU Referencing always used. Continuous covariates are always log-transformed, independent of the distribution of the parameter on which they are added. Centering by the median (or user defined values) for the covariates. Always untransformed categorical covariates. Several categories per covariate possible but all need to be numeric and integers. IIV correlation parameters always 0.1 at the initial guess. Selection of PRED,RES,WRES outputs dependent on the method that is used for estimation (in the tables renamed to: XPRED, XRES, XWRES): PREDI RESI WRESI if FO CPREDI, CRESI, CWRESI if FOCE EPRED, ERES, EWRES if SAEM Default values for add and prop errors: 1 and 0.3 Dataset can contain CMT or (ADM+YTYPE) columns. The output on the screen of this function will guide the user as to the needed values in these columns. ADM+YTYPE but not CMT YTYPE defines number of output ADM used as CMT column (states reordered to accomodate) ADM+CMT but not YTYPE YTYPE is inferred based on CMT for observation records (in $ERROR) But this means that CMT needs to follow the OUTPUTn numbering! CMT will be used as defined for selecting the dosing compartments ADM is used to inform potential switchings for NONMEM parameters in the PK section "]
]
